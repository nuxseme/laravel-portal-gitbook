{"./":{"url":"./","title":"Introduction","keywords":"","body":"laravel-portal 优雅 简洁 生态完善 "},"1-安装Homestead.html":{"url":"1-安装Homestead.html","title":"安装Homestead","keywords":"","body":"Homestead what 安装virtual box 提供虚拟能力 安装vagrant 客户端提供vagrant box 管理能力 安装vagrant box 提供操作系统的能力 安装homestead 官方配置 安装项目，同步文件并启动 Virtual Box 可选择安装virtual box 或者vm，vm扩展需要收费 这里安装virtual box 安装过程参考官方 Vagrant vagrant客户端，提供box 启动销毁更新等一系列能力安装件官方 Homestead Box 可以把Homestead Box 理解成集成了nginx mysql pgsql php-version ssh vim等等包的iso镜像,homestead box 基于Ubuntu的，也可以自己基于centos构建自己的镜像 直接官方安装太慢，建议先下载box文件，在本地安装 解压之后一般会有metadata文件，没有的话需要手动添加镜像 #vagrant box add metadata.json Homestead github克隆Homestead 修改Homestead.yaml文件，这个文件包含了共享文件目录，数据库，ssh pub-key，内存，cpu核数,ip地址 1 配置独立的ssh key 2 共享目录建议只映射必要的目录 3 ip地址需要修改hosts 4 多个站点可以配置多核站点映射，最终都将生成nginx配置 这套东西可以干啥 1 解决懒人配置，homestead box提供了大部分能想到的镜像能力，免去了每次都需要配置包依赖，各种工具的安装 2 分离项目代码和开发环境，代码可以主机目录和虚拟机目录同步，数据库，日志这些都可以预先设置，开发环境的销毁重建不会影响到已有数据 3 开发环境一致，解决协作之间由环境不一致引发的bug,开发即测试，测试即灰度，灰度及生产。有新的需求建立开发环境可以直接分享Homestead的配置，也支持个性化的定制配置 替代方案 docker image + docker composer编排配置 基本无差，docker国内生态比较完善，下载安装速度比较快，资源比较多 "},"2-目录结构.html":{"url":"2-目录结构.html","title":"目录结构","keywords":"","body":"目录结构 ├── app 应用程序核心代码 ├── bootstrap app框架引导文件及cache目录 ├── config 配置目录 ├── database db工具目录 ├── public 应用入口 ├── resources 前端资源目录 ├── routes 路由目录 ├── storage 存储目录 ├── tests 单元测试目录 ├── vendor 第三方库 App目录 ├── Console 控制台目录 │ └── Kernel.php ├── Exceptions 异常 │ └── Handler.php ├── Http web目录 │ ├── Controllers 应用层接口 │ ├── Kernel.php │ └── Middleware 中间件 ├── Providers 服务提供者 │ ├── AppServiceProvider.php │ ├── AuthServiceProvider.php 如果按ddd，默认缺少模型层，仓库，基础设施，事件目录可以自行添加 "},"3-生命周期.html":{"url":"3-生命周期.html","title":"生命周期","keywords":"","body":"生命周期 public index.php 加载composer 自动加载器 引入app启动项，返回app实例，app实例绑定了http,console kernel类 http kernel 处理请求并返回response http/kernel->handle sendRequestThroughRouter() bootstrap 加载启动项目 pipeline 实现中间件的调度 dispatchToRouter 路由调度器 调度一系列中间件，最后调度路由器 Routing/Route->run runController getController parseControllerCallback public static function parseCallback($callback, $default = null) { return static::contains($callback, '@') ? explode('@', $callback, 2) : [$callback, $default]; }//@分隔符分割controller和action Routing\\Controller callAction 希望具有before action 和after action的能力可以重写Routing\\Controller的callAction tips: debug_backtrace();//跟踪程序调用堆栈 "},"4-app.php是如何加载的.html":{"url":"4-app.php是如何加载的.html","title":"app.php是如何加载的","keywords":"","body":"///vendor/laravel/framework/src/Illuminate/Foundation/Http/Kernel.php protected $bootstrappers = [ \\Illuminate\\Foundation\\Bootstrap\\LoadEnvironmentVariables::class, \\Illuminate\\Foundation\\Bootstrap\\LoadConfiguration::class, \\Illuminate\\Foundation\\Bootstrap\\HandleExceptions::class, \\Illuminate\\Foundation\\Bootstrap\\RegisterFacades::class, \\Illuminate\\Foundation\\Bootstrap\\RegisterProviders::class, \\Illuminate\\Foundation\\Bootstrap\\BootProviders::class, ]; protected function sendRequestThroughRouter($request) { $this->app->instance('request', $request); Facade::clearResolvedInstance('request'); $this->bootstrap(); return (new Pipeline($this->app)) ->send($request) ->through($this->app->shouldSkipMiddleware() ? [] : $this->middleware) ->then($this->dispatchToRouter()); } public function bootstrapWith(array $bootstrappers) { $this->hasBeenBootstrapped = true; foreach ($bootstrappers as $bootstrapper) { $this['events']->dispatch('bootstrapping: '.$bootstrapper, [$this]); $this->make($bootstrapper)->bootstrap($this); $this['events']->dispatch('bootstrapped: '.$bootstrapper, [$this]); } } //vendor/laravel/framework/src/Illuminate/Foundation/Bootstrap/LoadConfiguration.php public function bootstrap(Application $app) { $items = []; // First we will see if we have a cache configuration file. If we do, we'll load // the configuration items from that file so that it is very quick. Otherwise // we will need to spin through every configuration file and load them all. if (file_exists($cached = $app->getCachedConfigPath())) { $items = require $cached; $loadedFromCache = true; } // Next we will spin through all of the configuration files in the configuration // directory and load each one into the repository. This will make all of the // options available to the developer for use in various parts of this app. $app->instance('config', $config = new Repository($items)); if (! isset($loadedFromCache)) { $this->loadConfigurationFiles($app, $config); } // Finally, we will set the application's environment based on the configuration // values that were loaded. We will pass a callback which will be used to get // the environment in a web context where an \"--env\" switch is not present. $app->detectEnvironment(function () use ($config) { return $config->get('app.env', 'production'); }); date_default_timezone_set($config->get('app.timezone', 'UTC')); mb_internal_encoding('UTF-8'); } protected function loadConfigurationFiles(Application $app, RepositoryContract $repository) { $files = $this->getConfigurationFiles($app); if (! isset($files['app'])) { throw new Exception('Unable to load the \"app\" configuration file.'); } foreach ($files as $key => $path) { //这里require $repository->set($key, require $path); } } app.php 作为系统配置文件，引入一般是在框架初始化阶段，需要在这个阶段定义环境变量，依赖关系，错误异常处理，以及缓存队列等配置信息 "},"5-路由配置文件是如何使用的.html":{"url":"5-路由配置文件是如何使用的.html","title":"路由配置文件是如何使用的","keywords":"","body":"问题：路由文件分为api.php web.php。默认是匹配到web文件，带有/api/的匹配的api定义的路由是如何实现的 1 Kernel bootstrap 阶段 \\Illuminate\\Foundation\\Bootstrap\\RegisterProviders::class 2 引入app文件的服务供给器 针对api.php文件的路由增加了前缀 public function registerConfiguredProviders() { $providers = Collection::make($this->config['app.providers']) ->partition(function ($provider) { return strpos($provider, 'Illuminate\\\\') === 0; }); $providers->splice(1, 0, [$this->make(PackageManifest::class)->providers()]); (new ProviderRepository($this, new Filesystem, $this->getCachedServicesPath())) ->load($providers->collapse()->toArray()); } 3 RouteServiceProvider public function map() { $this->mapApiRoutes(); $this->mapWebRoutes(); // } */ protected function mapWebRoutes() { Route::middleware('web') ->namespace($this->namespace) ->group(base_path('routes/web.php')); } /** * Define the \"api\" routes for the application. * * These routes are typically stateless. * * @return void */ protected function mapApiRoutes() { Route::prefix('api') ->middleware('api') ->namespace($this->namespace) ->group(base_path('routes/api.php')); } Route 根据Facade获取到的是$app下的router 实例 这里将api.php web.php路由配置保存到router里面 4 kernel 在中间件处理完之后调用router解析返回适配的路由 protected function dispatchToRouter() { return function ($request) { $this->app->instance('request', $request); return $this->router->dispatch($request); }; } //这里通过router解析了路由，拿到request和路由配置，解析，适配返回最终匹配的路由 "},"6-Facade静态引用是如何实现的.html":{"url":"6-Facade静态引用是如何实现的.html","title":"Facade静态引用是如何实现的","keywords":"","body":"问题: index.php 实例化了$app 使用Facade 静态方法如何保证使用的是同一个实例 1 kernel \\Illuminate\\Foundation\\Bootstrap\\RegisterFacades::class bootstarp配置引入Facade注册 2 Facade bootStarp public function bootstrap(Application $app) { //清空实例 Facade::clearResolvedInstances(); //设置当前$app实例 Facade::setFacadeApplication($app); AliasLoader::getInstance(array_merge( $app->make('config')->get('app.aliases', []), $app->make(PackageManifest::class)->aliases() ))->register(); } //绑定当前的$app 到facade定义的静态变量$app下 public static function setFacadeApplication($app) { static::$app = $app; } 3 举例说明Route::get class Route extends Facade { /** * Get the registered name of the component. * * @return string */ //定义返回的实例 protected static function getFacadeAccessor() { return 'router'; } } //魔术方法 public static function __callStatic($method, $args) { $instance = static::getFacadeRoot(); if (! $instance) { throw new RuntimeException('A facade root has not been set.'); } return $instance->$method(...$args); } //到$app解析对应的实例 protected static function resolveFacadeInstance($name) { if (is_object($name)) { return $name; } if (isset(static::$resolvedInstance[$name])) { return static::$resolvedInstance[$name]; } if (static::$app) { return static::$resolvedInstance[$name] = static::$app[$name]; } } "},"部署.html":{"url":"部署.html","title":"部署","keywords":"","body":""},"路由.html":{"url":"路由.html","title":"路由","keywords":"","body":""},"认证.html":{"url":"认证.html","title":"认证","keywords":"","body":""},"容器.html":{"url":"容器.html","title":"容器","keywords":"","body":""}}